<p align="center">
  <img width="250" src="https://i.ibb.co/BgZ8PBg/v8-logo-big.png">
  <br>
  <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Handjet&duration=2000&pause=1000&color=F7F7F7&center=true&vCenter=true&width=200&height=100&lines=CVE-2020-16040" alt="Typing SVG" /></a>
  </br>
</p>

## Overview

```text
[compiler] Fix a bug in SimplifiedLowering

SL's VisitSpeculativeIntegerAdditiveOp was setting Signed32 as
restriction type even when relying on a Word32 truncation in
order to skip the overflow check. This is not sound.
```
Reference(s):
	[chromium bug tracker](http://crbug.com/1150649) | [commit ba1b2cc](https://github.com/v8/v8/commit/ba1b2cc) | [patch diff](https://github.com/v8/v8/commit/ba1b2cc#diff-c962d253ffc68e1fafb3bc2c285f94b121aab2551fe7f7c9a99bb84a032c03b1)

To summarise, the problem was due to a mis-typing of nodes despite the value wrapping/overflowing. Which allowed for a typer hardening bypass to achieve out- of-bounds r/w primitives, leading to arbitrary remote code execution within the renderer's process. Affects Chrome versions `<=87.0.4280.88`.

For testing, the shellcode will need to be altered to your own internal `LHOST` IP address and desired port, 
alternatively you can statically set your VM IP to `172.16.14.128` and catch the reverse shell on `tcp\443`. 

Not currently chained with a sandbox escape `--no-sandbox` only.

A debug version of this exploit has been included within [debug/debug.js](https://github.com/ret2eax/exploits/blob/main/CVE-2020-16040/debug/debug.js) for testing and debugging purposes against a local `./d8` build.

You can read my full analysis and exploitation write-up <a href="https://homecrew.dev/posts/cve-2020-16040.html">here</a>.

#### Improvement Considerations: 

* Chain w/ Mojo IPC binding sandbox escape for a full-chain exploit.
* Validate reliability in the event of;
	1. unexpected garbage collection (GC) events,
	2. layout of the heap changes,
	3. hardcoded offsets that can be removed in favour of dynamically scanning for values (if any)?

## Skipped Overflow Check

```cpp
bool CanOverflowSigned32(const Operator* op, Type left, Type right,
                         Zone* type_zone) {
  left = Type::Intersect(left, Type::Signed32(), type_zone);
  right = Type::Intersect(right, Type::Signed32(), type_zone);
  if (left.IsNone() || right.IsNone()) return false;
  switch (op->opcode()) {
    case IrOpcode::kSpeculativeSafeIntegerAdd:
      return (left.Max() + right.Max() > kMaxInt) ||
             (left.Min() + right.Min() < kMinInt);
    case IrOpcode::kSpeculativeSafeIntegerSubtract:
      return (left.Max() - right.Min() > kMaxInt) ||
             (left.Min() - right.Max() < kMinInt);
    default:
      UNREACHABLE();
  }
  return true;
}
```

## The Patch

In reference to the patch diff, we can see that the changes made, specifically that of the `RepresentationSelector` class in `simplified-lowering.cc`, ensures that the typing system handles overflows and wrapping conditions adequately. The important modification here, in this context, is the introduction of a new restriction type that manages the type constraints during certain operations, particularly those in respect of `Word32` truncations:

```c++
Type const restriction = truncation.IsUsedAsWord32() ? Type::Any() : Type::Signed32();
```

The new restriction type defined is used conditionally, depending on the truncation context, ensuring that the typing system accounts for these conditions more accurately, thus mitigating this bug.

### Patch Diff (Includes Regression)

```diff
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index a1f10f98fe5..ef56d56e447 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1409,7 +1409,6 @@ class RepresentationSelector {
                 IsSomePositiveOrderedNumber(input1_type)
             ? CheckForMinusZeroMode::kDontCheckForMinusZero
             : CheckForMinusZeroMode::kCheckForMinusZero;
-
     NodeProperties::ChangeOp(node, simplified()->CheckedInt32Mul(mz_mode));
   }
 
@@ -1453,6 +1452,13 @@ class RepresentationSelector {
 
     Type left_feedback_type = TypeOf(node->InputAt(0));
     Type right_feedback_type = TypeOf(node->InputAt(1));
+
+    // Using Signed32 as restriction type amounts to promising there won't be
+    // signed overflow. This is incompatible with relying on a Word32
+    // truncation in order to skip the overflow check.
+    Type const restriction =
+        truncation.IsUsedAsWord32() ? Type::Any() : Type::Signed32();
+
     // Handle the case when no int32 checks on inputs are necessary (but
     // an overflow check is needed on the output). Note that we do not
     // have to do any check if at most one side can be minus zero. For
@@ -1466,7 +1472,7 @@ class RepresentationSelector {
         right_upper.Is(Type::Signed32OrMinusZero()) &&
         (left_upper.Is(Type::Signed32()) || right_upper.Is(Type::Signed32()))) {
       VisitBinop<T>(node, UseInfo::TruncatingWord32(),
-                    MachineRepresentation::kWord32, Type::Signed32());
+                    MachineRepresentation::kWord32, restriction);
     } else {
       // If the output's truncation is identify-zeros, we can pass it
       // along. Moreover, if the operation is addition and we know the
@@ -1486,8 +1492,9 @@ class RepresentationSelector {
       UseInfo right_use = CheckedUseInfoAsWord32FromHint(hint, FeedbackSource(),
                                                          kIdentifyZeros);
       VisitBinop<T>(node, left_use, right_use, MachineRepresentation::kWord32,
-                    Type::Signed32());
+                    restriction);
     }
+
     if (lower<T>()) {
       if (truncation.IsUsedAsWord32() ||
           !CanOverflowSigned32(node->op(), left_feedback_type,
diff --git a/test/mjsunit/compiler/regress-1150649.js b/test/mjsunit/compiler/regress-1150649.js
new file mode 100644
index 00000000000..a193481a3a2
--- /dev/null
+++ b/test/mjsunit/compiler/regress-1150649.js
@@ -0,0 +1,24 @@
+// Copyright 2020 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --allow-natives-syntax
+
+function foo(a) {
+  var y = 0x7fffffff;  // 2^31 - 1
+
+  // Widen the static type of y (this condition never holds).
+  if (a == NaN) y = NaN;
+
+  // The next condition holds only in the warmup run. It leads to Smi
+  // (SignedSmall) feedback being collected for the addition below.
+  if (a) y = -1;
+
+  const z = (y + 1)|0;
+  return z < 0;
+}
+
+%PrepareFunctionForOptimization(foo);
+assertFalse(foo(true));
+%OptimizeFunctionOnNextCall(foo);
+assertTrue(foo(false));
```

